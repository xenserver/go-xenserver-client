package client

import (
	"fmt"
	"github.com/nilshell/xmlrpc"
	"strconv"
)

type Network XenAPIObject

func (self *Network) GetAssignedIPs() (ipMap map[string]string, err error) {
	ipMap = make(map[string]string, 0)
	result := APIResult{}
	err = self.Client.APICall(&result, "network.get_assigned_ips", self.Ref)
	if err != nil {
		return ipMap, err
	}
	for k, v := range result.Value.(xmlrpc.Struct) {
		ipMap[k] = v.(string)
	}
	return ipMap, nil
}

func (self *Network) GetOtherConfig() (otherConfig map[string]string, err error) {
	otherConfig = make(map[string]string, 0)
	result := APIResult{}
	err = self.Client.APICall(&result, "network.get_other_config", self.Ref)
	if err != nil {
		return otherConfig, err
	}
	for k, v := range result.Value.(xmlrpc.Struct) {
		otherConfig[k] = v.(string)
	}
	return otherConfig, nil
}

func (self *Network) IsHostInternalManagementNetwork() (isHostInternalManagementNetwork bool, err error) {
	other_config, err := self.GetOtherConfig()
	if err != nil {
		return false, nil
	}
	value, ok := other_config["is_host_internal_management_network"]
	isHostInternalManagementNetwork = ok && value == "true"
	return isHostInternalManagementNetwork, nil
}

func (self *Network) Destroy() (err error) {
	result := APIResult{}
	err = self.Client.APICall(&result, "network.destroy", self.Ref)
	if err != nil {
		return err
	}
	return
}

func (self *Network) GetNameLabel() (name_label string, err error) {
	result := APIResult{}
	err = self.Client.APICall(&result, "network.get_name_label", self.Ref)
	if err != nil {
		return "", err
	}
	name_label = result.Value.(string)
	return
}

func (self *Network) GetUuid() (uuid string, err error) {
	result := APIResult{}
	err = self.Client.APICall(&result, "network.get_uuid", self.Ref)
	if err != nil {
		return "", err
	}
	uuid = result.Value.(string)
	return
}

func (self *Network) CreateVIF(vm_ref, mac string, device int) (vif *VIF, err error) {

	if err != nil {
		return nil, err
	}

	vif = self.Client.NewVIF()
	oc := make(xmlrpc.Struct)

	vif_rec := make(xmlrpc.Struct)

	vif_rec["uuid"] = ""
	vif_rec["allowed_operations"] = make([]interface{}, 1)
	vif_rec["current_operations"] = make([]interface{}, 1)
	vif_rec["device"] = strconv.Itoa(device)
	vif_rec["network"] = self.Ref
	vif_rec["VM"] = vm_ref
	vif_rec["MAC"] = mac
	//vif_rec["MAC"] = ""
	vif_rec["MTU"] = "0"
	vif_rec["other_config"] = oc
	vif_rec["currently_attached"] = false
	vif_rec["status_code"] = "0"
	vif_rec["status_detail"] = ""
	vif_rec["runtime_properties"] = oc
	vif_rec["qos_algorithm_type"] = ""
	vif_rec["qos_algorithm_params"] = oc
	vif_rec["qos_supported_algorithms"] = make([]interface{}, 1)
	vif_rec["metrics"] = ""
	vif_rec["MAC_autogenerated"] = true
	vif_rec["locking_mode"] = "network_default"
	vif_rec["ipv4_allowed"] = make([]interface{}, 1)
	vif_rec["ipv6_allowed"] = make([]interface{}, 1)
	vif_rec["ipv4_configuration_mode"] = "None"
	vif_rec["ipv4_addresses"] = make([]interface{}, 1)
	vif_rec["ipv4_gateway"] = ""
	vif_rec["ipv6_configuration_mode"] = "None"
	vif_rec["ipv6_addresses"] = make([]interface{}, 1)
	vif_rec["ipv6_gateway"] = ""

	result := APIResult{}
	err = self.Client.APICall(&result, "VIF.create", vif_rec)
	if err != nil {
		return nil, err
	}
	vif.Ref = ""
	if result.Value != nil {
		vif.Ref = result.Value.(string)
	} else {
		return nil, fmt.Errorf("Could not get the reference of vif.")
	}

	return vif, nil
}
